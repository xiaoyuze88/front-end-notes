# 知识点汇总

## 并归排序
将数组拆分到剩 Array(1)，然后依次比较两数组的左0，小的推出

logn = log2^n

每次划分1/2，共需要递归 log n 层，每层都需要遍历 n 个元素，所以复杂度是 O(n*logn)

相关问题：
median-of-two-sorted-arrays

## 快排
每次找一个基准，小的放左边，大的放右边，然后左右区间继续找基准
最好情况：每次挑到的正好就是中值，这样需要操作 logn 层，每层需要遍历全数组n，复杂度 nlogn
最坏情况：整个数组的顺序反过来，那么每次操作都需要将所有元素都移动一遍，而且需要挑 n 次，复杂度 n^2
平均情况：复杂度 nlogn

## 二分法

平均复杂度 O(logN)

## 堆
建堆，插入式建堆复杂度 O(n)
满n后，新插入一个，最坏需要一直冒泡到顶，复杂度 O(logn)
删除一个同理，复杂度O(logn)
所以堆排序，第一层 需要 logn+logn-1+logn-2...+log1=log(n*n-1*n-2*...*1) = log(n!) 约等于 log(n*logn)

## 动态规划
1. 拆分子问题
2. 记住前面的结果
3. 状态转移方程
4. 边界条件

相关问题：
1. 正则 regular-expression-matching
2. 最长回文串 longest-palindromic-substring

## 最大公约数 gcd

辗转相除法

function gcd(a, b) {
  if (b === 0) return a;

  return gcd(b, a % b);
}

相关问题：
greatest-common-divisor-of-strings

## 双指针
1. 双指针遍历
2. 滑动窗口，固定窗口大小
3. 动态滑动窗口，毛毛虫法，先一只脚往前爬，直到不满足条件，然后另一只脚拉过来（一步一步判断直到再次满足条件）

## HashMap/HashSet

## 栈
先入后出

碰到括号匹配的问题，碰到开头符号推入栈，同时栈内需保留上下文，以供pop后处理当前上下文

## 队列
先进先出

## 链表

1. 快慢指针，用于找中点
2. 反转链表：递归法、迭代法，依次交替next方向

## 位运算

1. 比特数算法：

n & n-1，会将 n 的最后一个1变为0，将 n = n & n-1 操作k次后，最后会得0，这个k就是 n 中 1 的个数

2. 异或运算 xor js运算符: ^

两种种仅有一个1时，得到1，否则得到0： 1 ^ 1 = 0; 0 ^ 0 = 0; 1 ^ 0 = 1;

由该特性可知，如果两个相等的数异或，将会得到0，因为每一位都相等，故：

a ^ a ^ b ^ b ^ c = c

3. 按位与以及左右位偏移符

特性1：x & 1 可以得到 x 第 1 个二进制位的数，如：3 & 1= 0011 & 1 = 1, 2 & 1= 0010 & 1 = 0;

特性2：同理，可知 x & (1 << k) 可以得到 x 第 k 个二进制位是否为1：如: 4 & (1 << 2) = 1010 & 0100 = 0; 4 & (1 << 1) = 1010 & 0010 = 1010 > 0，所以第1位为1

特性3：(x >> k) & 1 可以得到 x 第 k 位的数，如：(4 >> 2) & 1 = 0010 & 1 = 0; (4 >> 1) & 1 = 0101 & 1 = 1

4. 二进制位数计算：

2^n=Math.pow(2,n)
如一个数小于 10^9 = 1000000000
而 Math.pow(2, 31) = 1073741824，所以 n 必顶小于等于 30

## 二叉树

## 单调栈（monotonic stack）

