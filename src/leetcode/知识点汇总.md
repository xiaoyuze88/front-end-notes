# 知识点汇总

## 1. 动态规划
1. 拆分子问题
2. 记住前面的结果
3. 状态转移方程
4. 边界条件

相关问题：
1. 正则 regular-expression-matching
2. 最长回文串 longest-palindromic-substring

## 2. 并归排序
将数组拆分到剩 Array(1)，然后依次比较两数组的左0，小的推出

相关问题：
median-of-two-sorted-arrays

## 3. 最大公约数 gcd

辗转相除法

function gcd(a, b) {
  if (b === 0) return a;

  return gcd(b, a % b);
}

相关问题：
greatest-common-divisor-of-strings

## 4. 双指针
1. 双指针遍历
2. 滑动窗口，固定窗口大小
3. 动态滑动窗口，毛毛虫法，先一只脚往前爬，直到不满足条件，然后另一只脚拉过来（一步一步判断直到再次满足条件）

## 5. HashMap/HashSet

## 6. 栈
先入后出

碰到括号匹配的问题，碰到开头符号推入栈，同时栈内需保留上下文，以供pop后处理当前上下文

## 7. 队列
先进先出

## 8. 链表

1. 快慢指针，用于找中点
2. 反转链表：递归法、迭代法，依次交替next方向

## 9. 位运算

1. 比特数算法：

n & n-1，会将 n 的最后一个1变为0，将 n = n & n-1 操作k次后，最后会得0，这个k就是 n 中 1 的个数

2. 异或运算 xor js运算符: ^

两种种仅有一个1时，得到1，否则得到0： 1 ^ 1 = 0; 0 ^ 0 = 0; 1 ^ 0 = 1;

由该特性可知，如果两个相等的数异或，将会得到0，因为每一位都相等，故：

a ^ a ^ b ^ b ^ c = c

3. 按位与以及左右位偏移符

特性1：x & 1 可以得到 x 第 1 个二进制位的数，如：3 & 1= 0011 & 1 = 1, 2 & 1= 0010 & 1 = 0;

特性2：同理，可知 x & (1 << k) 可以得到 x 第 k 个二进制位是否为1：如: 4 & (1 << 2) = 1010 & 0100 = 0; 4 & (1 << 1) = 1010 & 0010 = 1010 > 0，所以第1位为1

特性3：(x >> k) & 1 可以得到 x 第 k 位的数，如：(4 >> 2) & 1 = 0010 & 1 = 0; (4 >> 1) & 1 = 0101 & 1 = 1

4. 二进制位数计算：

2^n=Math.pow(2,n)
如一个数小于 10^9 = 1000000000
而 Math.pow(2, 31) = 1073741824，所以 n 必顶小于等于 30